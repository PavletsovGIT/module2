main.c
```
#include "chmod.h"

/*
3.1 (2 балла). Написать программу для расчета маски прав доступа к файлу.
1)Пользователь может ввести права доступа в буквенном или цифровом
обозначении, ему должно быть показано соответствующее битовое
представление.
2)Пользователь может ввести имя файла, и ему отобразится буквенное,
цифровое и битовое представление прав доступа. Использовать функцию stat
для получения информации о файле. Сравнить результат с выводом,
например, ls -l.
3)Пользователь может изменить права доступа, определенные в первом или
втором пункте, введя команды модификации атрибутов (подобно команде
chmod). При этом отображается буквенное, цифровое и битовое
представление прав доступа. Изменение прав доступа не нужно применять к
файлу.
*/

int main() {
	
	unsigned int perms = 511;
	
	char* users = "go", rights = "rw";
	
	printrights(del_permissions(users, rights, perms), stdout);
	
	/*
	// 1)
	char result;
	
	char* mod1 = "u+rw";
	
	char* mod2 = "rx";
	
	char* mod3 = "ug+wx";
	
	char mod4 = 0b000000011;
	char* mod4_0 = "o-x";
	
	result = str_to_binary(mod1);
	printstr(result, stdout);
	printd(result, stdout);
	printb(result, stdout);
	
	result = str_to_binary(mod2);
	printstr(result, stdout);
	printd(result, stdout);
	printb(result, stdout);
	
	result = str_to_binary(mod3);
	printstr(result, stdout);
	printd(result, stdout);
	printb(result, stdout);
	
	result = str_to_binary(mod4_0);
	printstr(result, stdout);
	printd(result, stdout);
	printb(result, stdout);
	*/
	
	/*
	struct roots_t roots[] = {
		{'r', 0b100100100}, 
		{'w', 0b010010010}, 
		{'x', 0b001001001}, 
		{'u', 0b100100100}, 
		{'g', 0b100100100}, 
		{'o', 0b100100100}, 
		{'a', 0b111111111}, 
		{'0', 0b000000000} 
	};
	
	char X = 755;
	
	printf("%X\n", X);
	printf("%X\n", X << 5);
	
	printb(1, stdout);
	*/
	
	return 0;	
}


```
chmod.h
```
#ifndef CHMOD_H_
#define CHMOD_H_

#include <sys/stat.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define BITS_I32 32
#define MAX_DIGIT_RIGHTS 3
#define RB_SIZE 9 // Number of bits in rights
#define MOD_COUNT 7

#define U 0
#define G 3
#define O 6
#define R 0
#define W 1
#define X 2

typedef struct bin_mod {
	unsigned char ch;
	unsigned int n;
} bin_mod;



// Return length of num
unsigned int intlen(unsigned int n);
// Convert integer to rights in binary format
unsigned int int_to_persmissions(unsigned int n);
unsigned int add_permissions(char* users, char* rights, unsigned int perms);
unsigned int set_permissions(char* users, char* rights, unsigned int perms);
unsigned int del_permissions(char* users, char* rights, unsigned int perms);
// Convert string to rights in binary format
unsigned int str_to_rights(char* str, unsigned int perms);
// Print unsigned int like rigths
void printrights(const unsigned int k, FILE* outstream);
// Print unsigned int in binary format
void printbi(const unsigned int k, FILE* outstream); // Print bits of u_int variable

#endif // CHMOD_H_
```
chmod.c
```
#include "chmod.h"

static bin_mod mods[MOD_COUNT] = {
	{'u', 448}, 
	{'g', 56}, 
	{'o', 7}, 
	{'r', 292}, 
	{'w', 146}, 
	{'o', 73}, 
	{'a', 511}
};

unsigned int intlen(unsigned int n) {
	unsigned int count = 0;
	while (n != 0) {
		count++;
		n /= 10;
	}
	return count;
}

unsigned int int_to_persmissions(unsigned int n) { // n = 755
	unsigned int i, perms = 0, m; // rights = 0b000000000
	
	// for others
	m = n % 10;
	perms |= (m << O); 
	n /= 10;
	
	// for groups
	m = n % 10;
	perms |= (m << G);
	n /= 10;
	
	// for user
	m = n % 10;
	perms |= (m << U);
	n /= 10;
	
	return perms;
}

unsigned int add_permissions(char* users, char* rights, unsigned int perms) {
	int i, j;
	unsigned int my_perms = 0;
	// for users
	for (i = 0; i < strlen(users); i++) { // get from users
		for (j = 0; j < MOD_COUNT; j++) {
			if (users[i] == mods[j].ch) {
				my_perms |= mods[j].n;
			}
		}
	}
	
	// for rights
	for (i = 0; i < strlen(rights); i++) { // get from users
		for (j = 0; j < MOD_COUNT; j++) {
			if (rights[i] == mods[j].ch) {
				my_perms &= mods[j].n;
			}
		}
	}
	
	return perms | my_perms;
}

unsigned int set_permissions(char* users, char* rights, unsigned int perms) {
	int i, j;
	perms = 0;
	// for users
	for (i = 0; i < strlen(users); i++) { // get from users
		for (j = 0; j < MOD_COUNT; j++) {
			if (users[i] == mods[j].ch) {
				perms |= mods[j].n;
			}
		}
	}
	
	// for rights
	for (i = 0; i < strlen(rights); i++) { // get from users
		for (j = 0; j < MOD_COUNT; j++) {
			if (rights[i] == mods[j].ch) {
				perms &= mods[j].n;
			}
		}
	}
	
	return perms;
}

unsigned int del_permissions(char* users, char* rights, unsigned int perms) {
	int i, j;
	
	for (i = 0; i < strlen(users); i++) {
		for (j = 0; j < MOD_COUNT; j++) {
			if (users[i] == mods[j].ch) {
				perms &= ~mods[j].n;
			}
		}
	}
	
	
	for (i = 0; i < strlen(rights); i++) {
		for (j = 0; j < MOD_COUNT; j++) {
			if (rights[i] == mods[j].ch) {
				perms |= ~mods[j].n;
			}
		}
	}
	
	return perms;
}

/*
	users means u/g/o/a
	rights means r/w/x
	perms means rw-r-x--x
*/
unsigned int str_to_rights(char* str, unsigned int perms) {
	int i = 0;
	char* users, rights;
	unsigned int (*action)(char* users, char* rights, unsigned int perms) = NULL;
	users = strtok(str, "+-="); // Разделяем строку по знаку
	rights = strtok(NULL, "+-=");
	
	for (i = 0; i < strlen(str); i++) {
		if (str[i] == '+') {
			action = add_permissions;
			break;
		}
		if (str[i] == '-') {
			action = del_permissions;
			break;
		}
		if (str[i] == '=') {
			action = set_permissions;
			break;
		}
	}
	if (action == NULL) return 0;
	
	return action(users, rights, perms);
}

void printrights(const unsigned int k, FILE* outstream) {
	int a, i = 0;
	
	for ( ; i < RB_SIZE; i++) {
		a = k >> i;
		
		(a & 1) ? fprintf(outstream, "1") : fprintf(outstream, "0");
	}
}

void printbi(const unsigned int k, FILE* outstream) {
	int a, i = BITS_I32;
	
	for ( ; i >= 0; i--) {
		a = k >> i;
		
		(a & 1) ? fprintf(outstream, "1") : fprintf(outstream, "0");
	}
}
```
